/*
 * For use in distributed.net projects only.
 * Any other distribution or use of this source violates copyright.
 *
 * This file (ogr_fb.mac) contains all the macros etc. for LOOKUP_FIRSTBLANK
 * on all the different architectures.
 */
#define __OGR_FB_MAC__ "@(#)$Id: ogr_fb.mac,v 1.5 2007/10/22 16:48:30 jlawson Exp $"

#if !defined(OGROPT_HAVE_FIND_FIRST_ZERO_BIT_ASM) /* 0 <= x < 0xfffffffe */
  static const char ogr_first_blank_8bit[256] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 8, 9
  };
  #if defined(ASM_ARM) && defined(__GNUC__)
    static __inline__ int LOOKUP_FIRSTBLANK(register unsigned int input)
    {
      register int temp, result;
      __asm__ ("mov     %0,#0\n\t"             \
               "cmp     %1,#0xffff0000\n\t"    \
               "movcs   %1,%1,lsl#16\n\t"      \
               "addcs   %0,%0,#16\n\t"         \
               "cmp     %1,#0xff000000\n\t"    \
               "movcs   %1,%1,lsl#8\n\t"       \
               "ldrb    %1,[%3,%1,lsr#24]\n\t" \
               "addcs   %0,%0,#8\n\t"          \
               "add     %0,%0,%1"              \
               :"=r" (result), "=r" (temp) : "1" (input), "r" (ogr_first_blank_8bit));
      return result;
    }
  #else /* C code, no asm */
#if defined(__DECCXX)  /* For DEC/Compaq/HP C++ compiler on OpenVMS */
  #define __inline__ inline
#endif
  static __inline__ int LOOKUP_FIRSTBLANK(register unsigned int input)
  {
    register int result = 0;
    if (input >= 0xffff0000) {
      input <<= 16;
      result += 16;
    }
    if (input >= 0xff000000) {
      input <<= 8;
      result += 8;
    }
    result += ogr_first_blank_8bit[input>>24];
    return result;
  }
  #endif
#elif defined(__PPC__) || defined(ASM_PPC) || defined (__POWERPC__)/* CouNT Leading Zeros Word */
  #if defined(__GNUC__)
    static __inline__ int LOOKUP_FIRSTBLANK(register unsigned int i)
    { i = ~i; __asm__ ("cntlzw %0,%0" : "=r" (i) : "0" (i)); return ++i; }
  #elif (__MWERKS__) || (__MRC__)
    #define LOOKUP_FIRSTBLANK(x) (__cntlzw(~((unsigned int)(x)))+1)
  #else
    #error "Please check this (define OGR_TEST_FIRSTBLANK to test)"
  #endif
#elif defined(ASM_ALPHA)
  #if defined(ALPHA_CIX)
    #if defined(__GNUC__)
      static __inline__ int LOOKUP_FIRSTBLANK(register unsigned int i)
      {
        register unsigned long j = ~((unsigned long)i) << 32;
        __asm__ ("ctlz %0,%0" : "=r"(j) : "0" (j));
        return (int)(j & 0x1f)+1;
      }
    #else
    #error "Please check this (define OGR_TEST_FIRSTBLANK to test)"
      static inline int LOOKUP_FIRSTBLANK(register unsigned int i)
      {
        __int64 r = asm("ctlz %a0, %v0;", ~((unsigned long)i) << 32);
        return (int)(r)+1;
      }
    #endif
  #else
  #error OGROPT_HAVE_FIND_FIRST_ZERO_BIT_ASM is defined, and no code to match
  #endif
#elif defined(ASM_X86) && defined(__GNUC__) || \
      defined(__386__) && defined(__WATCOMC__) || \
      defined(__ICC)
  /* If we were to cover the whole range of 0x00000000 ... 0xffffffff
     we would need ...
     static __inline__ int LOOKUP_FIRSTBLANK(register unsigned int input)
     {
        register unsigned int result;
        __asm__("notl %1\n\t"     \
                "movl $33,%0\n\t" \
                "bsrl %1,%1\n\t"  \
                "jz   0f\n\t"     \
                "subl %1,%0\n\t"  \
                "decl %0\n\t"     \
                "0:"              \
                :"=r"(result), "=r"(input) : "1"(input) : "cc" );
        return result;
     }
     but since the function is only executed for (comp0 < 0xfffffffe),
     we can optimize it to...
  */
  #if defined(__GNUC__)
    static __inline__ int LOOKUP_FIRSTBLANK(register unsigned int input)
    {
       register unsigned int result;
       __asm__("notl %1\n\t"     \
               "movl $32,%0\n\t" \
               "bsrl %1,%1\n\t"  \
               "subl %1,%0\n\t"  \
               :"=r"(result), "=r"(input) : "1"(input) : "cc" );
       return result;
    }
  #elif defined(__WATCOMC__)
    int LOOKUP_FIRSTBLANK(unsigned int);
    #pragma aux LOOKUP_FIRSTBLANK =  \
                      "not  eax"     \
                      "mov  edx,20h" \
                      "bsr  eax,eax" \
                      "sub  edx,eax" \
            value [edx] parm [eax] modify exact [eax edx] nomemory;
  #else /* if defined(__ICC) */
    static inline int LOOKUP_FIRSTBLANK(register unsigned int i)
    {
      _asm mov eax,i
      _asm not eax
      _asm mov edx,20h
      _asm bsr eax,eax
      _asm sub edx,eax
      _asm mov i,edx
      return i;
    }
  #endif
#elif defined(ASM_68K) && defined(__GNUC__) /* Bit field find first one set (020+) */
  static __inline__ int LOOKUP_FIRSTBLANK(register unsigned int i)
  { i = ~i; __asm__ ("bfffo %0,0,0,%0" : "=d" (i) : "0" (i)); return ++i; }
#else
  #error OGROPT_HAVE_FIND_FIRST_ZERO_BIT_ASM is defined, and no code to match
#endif

