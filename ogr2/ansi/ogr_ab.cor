/*
 * For use in distributed.net projects only.
 * Any other distribution or use of this source violates copyright.
 *
 * This file (ogr_ab.cor) contains the core for OGROPT_ALTERNATE_CYCLE == 3.
 * It's based on GARSP 5.13 (ogr_g_r.cor).
 * It will get documentation and rewrite of major parts resulting in a nodecount
 * reduction and some speed improvements
 * This is currently being done by Andreas Beckmann.
 * Once completed, it should become a reference core for the next generation OGR
 * cores.
 * And it will be used in stubmap generation.
 */
#define __OGR_CORE__ "@(#)$Id: ogr_ab.cor,v 1.1.2.6 2001/02/13 00:59:12 andreasb Exp $"

#warning This core needs revision by other coders

/*

At first, a bit theory about searching Optimal Golomb Rulers and definitions.
(Some inspiration comes from gvantdoc.txt, ... )

OGR-N   Is the Optimal Golomb Ruler with N marks (including both endpoints).
        There are (N-1) first differences (see below) in this ruler.

level,
depth,
mark #      0 1  2    3     4        5      (N-1)
            *-*--*----*-----*--------*- ... -*
position    0 1  3    7    11       16      OGR_length[N-1]


differences 
        The distance between a pair of marks (not necessarily successive)
        is referred to as a "difference".  The length of the interval
        between two successive marks is referred to as a "first
        difference".
        
segment An interval of ruler from one mark to another.  There may be more
        than two marks in a segment.  The length of every possible segment 
        with k marks is at least as large as the OGR-k.

stub    A stub is a segment starting at the left end.  Stubs are distributed 
        to the clients to serve as start/endpoints of calculations.  The 
        clients starts searching at the stubs right end.

node    The search approach may be regarded as a tree search (with some
        clever pruning).  Each time a new mark is placed on a ruler under
        construction, the resulting starting segment of the ruler may be
        regarded as corresponding to a node of the search-tree.  The
        pruning techniques are such that leaf-nodes are rarely visited -
        backtrack having occurred well-before reaching that depth of the
        tree. 

length  A length is measured in units. The position of a mark is the 
        length from the rulers left end (position 0) to the mark.

depth   Depths are measured in the number of first differences. The depth/
        level of a mark is the number of first differences left of it.
        The depth of a segment is the number of first differences in it.


Basic search approach

The search starts at the left end with the stub.  Then marks are consecutively
added (without violating the OGR properties) to the right.  This stops, when 
the right end is reached (we found an optimal ruler) or a limit is exceeded
(we won't find an optimal ruler following this way).  Then we'll track back.
For every level a limit (rightmost mark position in this level) can be 
calculated. Simple idea: the segment between the current mark and the right
end must be at least as long as an OGR of the segments depth.


Mirror images

To simplify the search, no mirror rulers will be tested.  We'll only examine 
rulers for which the middle mark (or an approximation thereof) is on the left 
side of the midpoint of the ruler.


Three segments: left, middle, right

0                      half_depth   half_depth2                         (N-1)
*------left-----------------*--middle--*------------right-------------------*
0                      half_length                            OGR_length[N-1]

There are three segments in each ruler: left, middle and right segment. Left
and right segment have the same depth (number of first differences), but due
to mirror removal the right one is longer than the left one (except we will
find a shorter ruler). The middle segment is of depth 2 (N odd) or 3 (N even).

The remaining part of a segment/ruler is the segment between current mark 
(that will be placed at this level) and the rightmost mark of ruler/segment.


The Bitmaps DIST, LIST, COMP

comp, list, dist are bitmaps of arbitrary fixed length n (e.g. n = 160),
first/leftmost bit is #1, last/rightmost bit is #n

comp: bit 1 is right to the current mark, running right
      0 means: it's allowed to place a mark here
      1 means: can't place a mark here
list: current ruler as seen from the current mark (bit 0, not in bitmap!)
      to the left end -> looks like a mirror image of the ruler
dist: all used distances are marked with a 1


Choosing

To solve the question "What is the minimum length of an optimal golomb ruler
with M marks when the differences diff1, diff2, ... diffk are not available?"
the precalculated table ogr_choose_dat2 is used. The differences are limited
to the first CHOOSE_DIST_BITS of the DIST bitmap. Each additional bit doubles
the needed memory, but reduces the amount of nodes to be visited.


*/








#if (OGROPT_ALTERNATE_CYCLE == 3)

const char* ogr_name()
{
  return "AB 0.02 $Revision: 1.1.2.6 $";
}


#define COMP_LEFT_LIST_RIGHT(lev,s)                             \
  {                                                             \
    register int ss = 32 - s;                                   \
    lev->comp[0] = (lev->comp[0] << s) | (lev->comp[1] >> ss);  \
    lev->comp[1] = (lev->comp[1] << s) | (lev->comp[2] >> ss);  \
    lev->comp[2] = (lev->comp[2] << s) | (lev->comp[3] >> ss);  \
    lev->comp[3] = (lev->comp[3] << s) | (lev->comp[4] >> ss);  \
    lev->comp[4] <<= s;                                         \
    lev->list[4] = (lev->list[4] >> s) | (lev->list[3] << ss);  \
    lev->list[3] = (lev->list[3] >> s) | (lev->list[2] << ss);  \
    lev->list[2] = (lev->list[2] >> s) | (lev->list[1] << ss);  \
    lev->list[1] = (lev->list[1] >> s) | (lev->list[0] << ss);  \
    lev->list[0] >>= s;                                         \
  }

#if defined(ASM_ARM) && defined(__GNUC__)
  #define COMP_LEFT_LIST_RIGHT_32(lev) \
  { \
    int a1, a2; \
    \
    asm ("ldr %0,[%2,#44]\n \
          ldr %1,[%2,#48]\n \
          str %0,[%2,#40]\n \
          ldr %0,[%2,#52]\n \
          str %1,[%2,#44]\n \
          ldr %1,[%2,#56]\n \
          str %0,[%2,#48]\n \
          ldr %0,[%2,#12]\n \
          str %1,[%2,#52]\n \
          ldr %1,[%2,#8]\n \
          str %0,[%2,#16]\n \
          ldr %0,[%2,#4]\n \
          str %1,[%2,#12]\n \
          ldr %1,[%2,#0]\n \
          str %0,[%2,#8]\n \
          mov %0,#0\n \
          str %1,[%2,#4]\n \
          str %0,[%2,#56]\n \
          str %0,[%2,#0]" : \
         "=r" (a1), "=r" (a2),\
         "=r" (lev) : "2" (lev)); \
  }
#else
  #define COMP_LEFT_LIST_RIGHT_32(lev)              \
    lev->comp[0] = lev->comp[1];                    \
    lev->comp[1] = lev->comp[2];                    \
    lev->comp[2] = lev->comp[3];                    \
    lev->comp[3] = lev->comp[4];                    \
    lev->comp[4] = 0;                               \
    lev->list[4] = lev->list[3];                    \
    lev->list[3] = lev->list[2];                    \
    lev->list[2] = lev->list[1];                    \
    lev->list[1] = lev->list[0];                    \
    lev->list[0] = 0;
#endif

#if (OGROPT_BITOFLIST_DIRECT_BIT == 0) && (OGROPT_ALTERNATE_CYCLE == 3)
  #define BITOFLIST(x) ogr_bit_of_LIST[x] /* which bit of LIST to update */
  /* ogr_bit_of_LIST[n] = 0x80000000 >> ((n-1) % 32); */
  #define BoL(__n) (0x80000000 >> ((__n - 1) % 32)) //(0x80000000>>((__n - 1)&0x1f))
  static const U ogr_bit_of_LIST[200] = {
        0 , BoL(  1), BoL(  2), BoL(  3), BoL(  4), BoL(  5), BoL(  6), BoL(  7),
  BoL(  8), BoL(  9), BoL( 10), BoL( 11), BoL( 12), BoL( 13), BoL( 14), BoL( 15),
  BoL( 16), BoL( 17), BoL( 18), BoL( 19), BoL( 20), BoL( 21), BoL( 22), BoL( 23),
  BoL( 24), BoL( 25), BoL( 26), BoL( 27), BoL( 28), BoL( 29), BoL( 30), BoL( 31),
  BoL( 32), BoL( 33), BoL( 34), BoL( 35), BoL( 36), BoL( 37), BoL( 38), BoL( 39),
  BoL( 40), BoL( 41), BoL( 42), BoL( 43), BoL( 44), BoL( 45), BoL( 46), BoL( 47),
  BoL( 48), BoL( 49), BoL( 50), BoL( 51), BoL( 52), BoL( 53), BoL( 54), BoL( 55),
  BoL( 56), BoL( 57), BoL( 58), BoL( 59), BoL( 60), BoL( 61), BoL( 62), BoL( 63),
  BoL( 64), BoL( 65), BoL( 66), BoL( 67), BoL( 68), BoL( 69), BoL( 70), BoL( 71),
  BoL( 72), BoL( 73), BoL( 74), BoL( 75), BoL( 76), BoL( 77), BoL( 78), BoL( 79),
  BoL( 80), BoL( 81), BoL( 82), BoL( 83), BoL( 84), BoL( 85), BoL( 86), BoL( 87),
  BoL( 88), BoL( 89), BoL( 90), BoL( 91), BoL( 92), BoL( 93), BoL( 94), BoL( 95),
  BoL( 96), BoL( 97), BoL( 98), BoL( 99), BoL(100), BoL(101), BoL(102), BoL(103),
  BoL(104), BoL(105), BoL(106), BoL(107), BoL(108), BoL(109), BoL(110), BoL(111),
  BoL(112), BoL(113), BoL(114), BoL(115), BoL(116), BoL(117), BoL(118), BoL(119),
  BoL(120), BoL(121), BoL(122), BoL(123), BoL(124), BoL(125), BoL(126), BoL(127),
  BoL(128), BoL(129), BoL(130), BoL(131), BoL(132), BoL(133), BoL(134), BoL(135),
  BoL(136), BoL(137), BoL(138), BoL(139), BoL(140), BoL(141), BoL(142), BoL(143),
  BoL(144), BoL(145), BoL(146), BoL(147), BoL(148), BoL(149), BoL(150), BoL(151),
  BoL(152), BoL(153), BoL(154), BoL(155), BoL(156), BoL(157), BoL(158), BoL(159),
  BoL(160), BoL(161), BoL(162), BoL(163), BoL(164), BoL(165), BoL(166), BoL(167),
  BoL(168), BoL(169), BoL(170), BoL(171), BoL(172), BoL(173), BoL(174), BoL(175),
  BoL(176), BoL(177), BoL(178), BoL(179), BoL(180), BoL(181), BoL(182), BoL(183),
  BoL(184), BoL(185), BoL(186), BoL(187), BoL(188), BoL(189), BoL(190), BoL(191),
  BoL(192), BoL(193), BoL(194), BoL(195), BoL(196), BoL(197), BoL(198), BoL(199)
  #undef BoL
};
#else
  #define BITOFLIST(x) 0x80000000>>((x-1)&0x1f) /*0x80000000 >> ((x-1) % 32)*/
#endif


#if (OGROPT_COPY_LIST_SET_BIT_JUMPS == 1)
#define COPY_LIST_SET_BIT(lev2,lev,bitindex)      \
  {                                               \
    register unsigned int d = bitindex;           \
    lev2->list[0] = lev->list[0];                 \
    lev2->list[1] = lev->list[1];                 \
    lev2->list[2] = lev->list[2];                 \
    lev2->list[3] = lev->list[3];                 \
    lev2->list[4] = lev->list[4];                 \
    if (d <= (32*5))                              \
      lev2->list[(d-1)>>5] |= BITOFLIST( d );     \
  }
#elif (OGROPT_COPY_LIST_SET_BIT_JUMPS == 2)
#define COPY_LIST_SET_BIT(lev2,lev,bitindex)      \
  {                                               \
    register unsigned int d = bitindex;           \
    memcpy( &(lev2->list[0]), &(lev->list[0]), sizeof(lev2->list[0])*5 ); \
    if (d <= (32*5))                              \
      lev2->list[(d-1)>>5] |= BITOFLIST( d );     \
  }
#else
#define COPY_LIST_SET_BIT(lev2,lev,bitindex)      \
  {                                               \
    register unsigned int d = bitindex;           \
    register int bit = BITOFLIST( d );            \
    if (d <= 32) {                                \
       lev2->list[0] = lev->list[0] | bit;        \
       lev2->list[1] = lev->list[1];              \
       lev2->list[2] = lev->list[2];              \
       lev2->list[3] = lev->list[3];              \
       lev2->list[4] = lev->list[4];              \
    } else if (d <= 64) {                         \
       lev2->list[0] = lev->list[0];              \
       lev2->list[1] = lev->list[1] | bit;        \
       lev2->list[2] = lev->list[2];              \
       lev2->list[3] = lev->list[3];              \
       lev2->list[4] = lev->list[4];              \
    } else if (d <= 96) {                         \
       lev2->list[0] = lev->list[0];              \
       lev2->list[1] = lev->list[1];              \
       lev2->list[2] = lev->list[2] | bit;        \
       lev2->list[3] = lev->list[3];              \
       lev2->list[4] = lev->list[4];              \
    } else if (d <= 128) {                        \
       lev2->list[0] = lev->list[0];              \
       lev2->list[1] = lev->list[1];              \
       lev2->list[2] = lev->list[2];              \
       lev2->list[3] = lev->list[3] | bit;        \
       lev2->list[4] = lev->list[4];              \
    } else if (d <= 160) {                        \
       lev2->list[0] = lev->list[0];              \
       lev2->list[1] = lev->list[1];              \
       lev2->list[2] = lev->list[2];              \
       lev2->list[3] = lev->list[3];              \
       lev2->list[4] = lev->list[4] | bit;        \
    } else {                                      \
       lev2->list[0] = lev->list[0];              \
       lev2->list[1] = lev->list[1];              \
       lev2->list[2] = lev->list[2];              \
       lev2->list[3] = lev->list[3];              \
       lev2->list[4] = lev->list[4];              \
    }                                             \
  }
#endif

#define COPY_DIST_COMP(lev2,lev)                  \
  lev2->dist[0] = lev->dist[0] | lev2->list[0];   \
  lev2->dist[1] = lev->dist[1] | lev2->list[1];   \
  lev2->dist[2] = lev->dist[2] | lev2->list[2];   \
  lev2->dist[3] = lev->dist[3] | lev2->list[3];   \
  lev2->dist[4] = lev->dist[4] | lev2->list[4];   \
  lev2->comp[0] = lev->comp[0] | lev2->dist[0];   \
  lev2->comp[1] = lev->comp[1] | lev2->dist[1];   \
  lev2->comp[2] = lev->comp[2] | lev2->dist[2];   \
  lev2->comp[3] = lev->comp[3] | lev2->dist[3];   \
  lev2->comp[4] = lev->comp[4] | lev2->dist[4];

#define COPY_LIST_SET_BIT_COPY_DIST_COMP(lev2,lev,bitindex) \
  {                                   \
    int b, d;                         \
    int a0, a1, a2, a3, a4;           \
                                      \
    b = BITOFLIST(bitindex);          \
    d = bitindex;                     \
    if(d<=32)                         \
    {                                 \
      a0 = lev->list[0] | b;          \
      a1 = lev->list[1];              \
      a2 = lev->list[2];              \
      a3 = lev->list[3];              \
      a4 = lev->list[4];              \
    }                                 \
    else if(d<=64)                    \
    {                                 \
      a0 = lev->list[0];              \
      a1 = lev->list[1] | b;          \
      a2 = lev->list[2];              \
      a3 = lev->list[3];              \
      a4 = lev->list[4];              \
    }                                 \
    else if(d<=96)                    \
    {                                 \
      a0 = lev->list[0];              \
      a1 = lev->list[1];              \
      a2 = lev->list[2] | b;          \
      a3 = lev->list[3];              \
      a4 = lev->list[4];              \
    }                                 \
    else if(d<=128)                   \
    {                                 \
      a0 = lev->list[0];              \
      a1 = lev->list[1];              \
      a2 = lev->list[2];              \
      a3 = lev->list[3] | b;          \
      a4 = lev->list[4];              \
    }                                 \
    else if(d<=160)                   \
    {                                 \
      a0 = lev->list[0];              \
      a1 = lev->list[1];              \
      a2 = lev->list[2];              \
      a3 = lev->list[3];              \
      a4 = lev->list[4] | b;          \
    }                                 \
    else                              \
    {                                 \
      a0 = lev->list[0];              \
      a1 = lev->list[1];              \
      a2 = lev->list[2];              \
      a3 = lev->list[3];              \
      a4 = lev->list[4];              \
    }                                 \
    lev2->list[0] = a0;               \
    lev2->list[1] = a1;               \
    lev2->list[2] = a2;               \
    lev2->list[3] = a3;               \
    b = lev->dist[0];                 \
    lev2->list[4] = a4;               \
    a0 = b | a0;                      \
    b = lev->dist[1];                 \
    lev2->dist[0] = a0;               \
    a1 = b | a1;                      \
    b = lev->dist[2];                 \
    lev2->dist[1] = a1;               \
    a2 = b | a2;                      \
    b = lev->dist[3];                 \
    lev2->dist[2] = a2;               \
    a3 = b | a3;                      \
    b = lev->dist[4];                 \
    lev2->dist[3] = a3;               \
    a4 = b | a4;                      \
    b = lev->comp[0];                 \
    lev2->dist[4] = a4;               \
    a0 = b | a0;                      \
    b = lev->comp[1];                 \
    lev2->comp[0] = a0;               \
    a1 = b | a1;                      \
    b = lev->comp[2];                 \
    lev2->comp[1] = a1;               \
    a2 = b | a2;                      \
    b = lev->comp[3];                 \
    lev2->comp[2] = a2;               \
    a3 = b | a3;                      \
    b = lev->comp[4];                 \
    lev2->comp[3] = a3;               \
    a4 = b | a4;                      \
    lev2->comp[4] = a4;               \
  }


/* ************************************************************************* */

/* confirm that the ruler is golomb */
/* there is no optimization necessary, it will be called nearly never */
/* using bits instead of chars is ok */
/* use only the ogr_cycle() internal part of struct State */
/* retval 1 = is_golomb, 0 = not golomb */
static int found_one(const struct State *oState)
{
  {
    register int i, j;
    #if (OGROPT_FOUND_ONE_FOR_SMALL_DATA_CACHE == 0)
      char diffs[1024];
    #else
      char diffs[((1024)+7)/8];
    #endif
    register int maxdepth = oState->maxdepth;
    memset( diffs, 0, sizeof(diffs) );
    for (i = 1; i <= maxdepth; i++) {
      register int markpos_i = oState->Levels[i].cnt2;
      for (j = 0; j < i; j++) {
        register int diff = markpos_i - oState->Levels[j].cnt2;
        if (diff < 1024) {
          #if (OGROPT_FOUND_ONE_FOR_SMALL_DATA_CACHE == 0)
            if (diffs[diff]) return 0;
            diffs[diff] = 1;
          #else
            register int mask;
            mask = 1<<(diff&7);
            diff >>= 3;
            if ((diffs[diff] & mask)!=0) return 0;
            diffs[diff] |= (char)mask;
          #endif
        }
      }
    }
  }
  return 1;
}


/* ************************************************************************* */


static int ogr_create(void *input, int inputlen, void *state, int statelen)
{
  struct State *oState;
  struct WorkStub *workstub = (struct WorkStub *)input;
  int retval = CORE_S_OK;
  /* save STUB_E_ error codes into oState->stub_error and finish ogr_create() 
     to allow a graceful discard in case of a STUB_E_ */

  if (!input || inputlen != sizeof(struct WorkStub)) {
    return CORE_E_FORMAT;
  }

  if (((unsigned int)statelen) < sizeof(struct State)) {
    return CORE_E_FORMAT;
  }
  oState = (struct State *)state;
  if (!oState) {
    return CORE_E_MEMORY;
  }

  oState->stub_error = STUB_OK; 
  /* stub_error stores the STUB_E_ error codes. An oState with a non zero 
     stub_error will be rejected by ogr_cycle(), but returned to network */
    
  oState->maxmarks = workstub->stub.marks;
  oState->maxdepth = oState->maxmarks-1;

  if (((unsigned int)oState->maxmarks) > (sizeof(OGR_length)/sizeof(OGR_length[0]))) {
    return CORE_E_FORMAT;
  }

  oState->max = OGR_length[oState->maxdepth];

/* <ToDo> Rethink, Comments */
  /* Note, marks are labled 0, 1...  so mark @ depth=1 is 2nd mark */
  oState->half_depth2 = oState->half_depth = ((oState->maxmarks+1) >> 1) - 1;
  if (!(oState->maxmarks % 2)) oState->half_depth2++;  /* if even, use 2 marks */

  /* Simulate GVANT's "KTEST=1" */
  oState->half_depth--;
  oState->half_depth2++;
  /*------------------
  Since:  half_depth2 = half_depth+2 (or 3 if maxmarks even) ...
  We get: half_length2 >= half_length + 3 (or 6 if maxmarks even)
  But:    half_length2 + half_length <= max-1    (our midpoint reduction)
  So:     half_length + 3 (6 if maxmarks even) + half_length <= max-1
  ------------------*/
                               oState->half_length = (oState->max-4) >> 1;
  if ( !(oState->maxmarks%2) ) oState->half_length = (oState->max-7) >> 1;
/* </ToDo> */

  oState->depth = 1;
  
#ifdef OGROPT_NEW_CHOOSEDAT
  /* would we choose values somewhere behind the precalculated values from 
     ogr_choose_dat2 ? 
     choose(x,y) will be called from middle and right segment for the 
     remaining ruler, not including the current mark, so we can subtract 1 */
  if (oState->maxdepth - oState->half_depth - 1 > CHOOSE_MAX_DEPTH)
    oState->stub_error |= STUB_E_MARKS;  
#endif

#if (OGROPT_ALTERNATE_CYCLE == 3)

  {
    int i, n;
    struct Level *lev, *lev2;

    n = workstub->worklength;
    if (n < workstub->stub.length) {
      n = workstub->stub.length;
    }
    if (n > STUB_MAX) {
      return CORE_E_FORMAT;
    }

    /* // level 0 - already done by memset
    lev = &oState->Levels[0];
    lev->cnt1 = lev->cnt2 = oState->markpos[0] = 0;
    lev->limit = lev->maxlimit = 0;
    */
    
    lev = &oState->Levels[1];
    for (i = 0; i < n; i++) {
      int limit;
      if (oState->depth <= oState->half_depth2) {
        if (oState->depth <= oState->half_depth) {
          limit = oState->max - OGR_length[oState->maxdepth - oState->depth];
          limit = limit < oState->half_length ? limit : oState->half_length;
        } else {
          limit = oState->max - choose(lev->dist[0] >> ttmDISTBITS, oState->maxdepth - oState->depth);
          limit = limit < oState->max - oState->markpos[oState->half_depth]-1 ? limit : oState->max - oState->markpos[oState->half_depth]-1;
        }
      } else {
        limit = oState->max - choose(lev->dist[0] >> ttmDISTBITS, oState->maxdepth - oState->depth);
      }
      lev->limit = limit;
      register int s = workstub->stub.diffs[i];
      
      if (s <= (32*5))
        if (lev->comp[(s-1)>>5] & BITOFLIST(s))
          oState->stub_error |= STUB_E_GOLOMB;

      //dump(oState->depth, lev, 0);
      oState->markpos[i+1] = oState->markpos[i] + s;
      if ((lev->cnt2 += s) > limit)
        oState->stub_error |= STUB_E_LIMIT;

      register int t = s;
      while (t >= 32) {
        COMP_LEFT_LIST_RIGHT_32(lev);
        t -= 32;
      }
      if (t > 0) {
        COMP_LEFT_LIST_RIGHT(lev, t);
      }
      lev2 = lev + 1;
      COPY_LIST_SET_BIT(lev2, lev, s);
      COPY_DIST_COMP(lev2, lev);
      lev2->cnt1 = lev->cnt2;
      lev2->cnt2 = lev->cnt2;
      lev++;
      oState->depth++;
    }
    oState->depth--; // externally visible depth is one less than internal
  }

#else 
  #error no core specific ogr_create() code
#endif

  oState->startdepth = workstub->stub.length;

#ifdef OGR_WINDOW
   oState->wind = oState->depth;
   oState->turn = 0;
#endif
#ifdef OGR_PROFILE
   oState->prof.hd = 0;
   oState->prof.hd2 = 0;
   oState->prof.ghd = 0;
   oState->prof.lt16 = 0;
   oState->prof.lt32 = 0;
   oState->prof.ge32 = 0;
   oState->prof.fo = 0;
   oState->prof.push = 0;
#endif
#ifdef OGR_DEBUG
  printf("sizeof      = %d\n", sizeof(struct State));
  printf("max         = %d\n", oState->max);
  printf("maxmarks    = %d\n", oState->maxmarks);
  printf("maxdepth    = %d\n", oState->maxdepth);
  printf("half_length = %d\n", oState->half_length);
  printf("half_depth  = %d\n", oState->half_depth);
  printf("half_depth2 = %d\n", oState->half_depth2);
  {
    int i;
    printf("marks       = ");
     for (i = 1; i <= oState->depth; i++) {
      printf("%d ", oState->markpos[i]-oState->markpos[i-1]);
    }
    printf("\n");
  }
#endif

  return retval;
}


/* ************************************************************************* */


static int ogr_cycle(void *state, int *pnodes, int with_time_constraints)
{
  struct State *oState = (struct State *)state;
  /* oState->depth is the level of the last placed mark */
  int depth = oState->depth+1;      /* the depth of recursion */
  /* our depth is the level where the next mark (the "current mark") will be placed */
  struct Level *lev = &oState->Levels[depth];
  struct Level *lev2;
  int nodes = 0;
  int nodeslimit = *pnodes;
  int retval = CORE_S_CONTINUE;
  int limit;
  U comp0;
  
  /* this saves typing ... and cycles */
  register const int max = oState->max;
  register const int maxdepth = oState->maxdepth;
  register const int startdepth = oState->startdepth;
  register const int half_depth = oState->half_depth;
  register const int half_depth2 = oState->half_depth2;


  /* ogr_cycle() must be thread safe. Only modification of part 3 of oState is
   * allowed. Part 2 will be updated before leaving ogr_cycle after locking a
   * mutex.
   */

  if (oState->stub_error != STUB_OK) {
    *pnodes = 0;
    return CORE_S_OK; /* stub is "finished" */
  }
  
  OGR_DEBUG_CYCLE( oState->LOGGING = 1; )
  
  for (;;) {

    if (with_time_constraints) { /* if (...) is optimized away if unused */
       #if !defined(OGROPT_IGNORE_TIME_CONSTRAINT_ARG)
       if (nodes >= nodeslimit) {
         break;
       }  
       #endif  
    }

    OGR_DEBUG_CYCLE( if (oState->LOGGING) dump_ruler(oState, depth); )

    if (depth <= half_depth2) {
      if (depth <= half_depth) {
        /***** left segment *****/

        //dump_ruler(oState, depth);
        if (nodes >= nodeslimit) {
          break;
        }

        /* an OGR must fit into the remaining part of the ruler */
        /* an OGR must fit between current and rightmost mark */
        /* can't choose here - not enough depth in ogr_choose_dat */
        /* TODO: it's correct, but is it strong? perhaps it's useless if stubs
           are deep enough, and second test is applied */
        limit = max - OGR_length[maxdepth - depth];
        
        /* an OGR (with choosing!) must fit into the remaining part of the left segment */
        ////limit = limit < oState->half_length ? limit : oState->half_length;
        {
          /* leftlength + midlength + leftlenght+1 <= max */
          /* 2 leftlength <= max - midlength - 1          */
          /* leftlengthmax = (max - midlength - 1) / 2    */
          register int middle_segment_min_length = 
              choose(lev->dist[0] >> ttmDISTBITS, half_depth2 - half_depth);
          register int left_segment_limit = 
              (max - middle_segment_min_length - 1) >> 1;
          register int newlimit = 
              left_segment_limit - choose(lev->dist[0] >> ttmDISTBITS, half_depth - depth);
          if (newlimit < limit)
            limit = newlimit;
        }
        
      } else {
        /***** middle segment *****/

        /* an OGR (with choosing) must fit into the remaining part of the ruler */
        /* TODO: is this limit strong? Or gets it overridden always by the next test? */
        limit = max - choose(lev->dist[0] >> ttmDISTBITS, maxdepth - depth);
        
        /* an OGR (with choosing!) must fit into the remaining part of the middle segment */
        ////limit = limit < oState->max - oState->Levels[oState->half_depth].cnt2-1  
        ////        ? limit : oState->max - oState->Levels[oState->half_depth].cnt2-1;
        {
          register int left_segment_length = oState->Levels[half_depth].cnt2;
          register int middle_segment_limit = max - left_segment_length - 1;
          register int newlimit = 
              middle_segment_limit - choose(lev->dist[0] >> ttmDISTBITS, half_depth2 - depth);
          if (newlimit < limit)
            limit = newlimit;
        }
      }
    } else {
      /***** right segment *****/
      
      /* an OGR (with choosing) must fit into the remaining part of the ruler */
      limit = max - choose(lev->dist[0] >> ttmDISTBITS, maxdepth - depth);
    }

    OGR_DEBUG_CYCLE( if (oState->LOGGING) dump(depth, lev, limit); )

    nodes++;

    /* Find the next available mark location for this level */
stay:
    comp0 = lev->comp[0];
    OGR_DEBUG_CYCLE( if (oState->LOGGING) printf("comp0=%08x\n", comp0); )
    if (comp0 < 0xfffffffe) {
      int s = LOOKUP_FIRSTBLANK( comp0 );
      OGR_DEBUG_CYCLE( if (oState->LOGGING) printf("depth=%d s=%d len=%d limit=%d\n", depth, s+(lev->cnt2-lev->cnt1), lev->cnt2+s, limit); )
      if ((lev->cnt2 += s) > limit) goto up; /* no spaces left */
      COMP_LEFT_LIST_RIGHT(lev, s);
    } else {
      /* s>32 */
      if ((lev->cnt2 += 32) > limit) goto up; /* no spaces left */
      COMP_LEFT_LIST_RIGHT_32(lev);
      if (comp0 == 0xffffffff) goto stay;
    }

/* ogr_cycle is being used for stubmap generation ... */
#ifdef OGR_CALLBACK
    if (depth == ogr_callback_depth) {
      // update part 2 of oState
      oState->depth = depth;

      for (int i = oState->startdepth+1; i <= oState->maxmarks; ++i) {
        oState->markpos[i] = oState->Levels[i].cnt2;
      }
      
      // don't update oState->nodes[hi|lo] !

      if (ogr_callback(oState) != 0)
        break;

      goto stay; /* don't go deeper, but repeat this level till done */
    }
#endif

    /* New ruler? */
    if (depth == maxdepth) {
      //oState->markpos[oState->maxdepth] = lev->cnt2;       /* not placed yet into list arrays! */
      /* found_one() doesn't use part 2 of State */
      if (found_one(oState)) {
        retval = CORE_S_SUCCESS;
        break;
      }
      goto stay;
    }

    /* Go Deeper */
    lev2 = lev + 1;
#if (OGROPT_COMBINE_COPY_LIST_SET_BIT_COPY_DIST_COMP == 1)
    COPY_LIST_SET_BIT_COPY_DIST_COMP(lev2, lev, lev->cnt2-lev->cnt1);
#else
    COPY_LIST_SET_BIT(lev2, lev, lev->cnt2-lev->cnt1);
    COPY_DIST_COMP(lev2, lev);
#endif
    //oState->markpos[depth] = lev->cnt2;
    lev2->cnt1 = lev->cnt2;
    lev2->cnt2 = lev->cnt2;
    lev->limit = limit;
    //oState->depth = depth;
    lev++;
    depth++;

    continue;

up:
    lev--;
    depth--;
    //oState->depth = depth-1;
    if (depth <= startdepth) {
      retval = CORE_S_OK;
      break;
    }
    limit = lev->limit;

    goto stay; /* repeat this level till done */
  }

  /* update part 2 of oState */
  oState->depth = depth-1;

  for (int i = oState->startdepth+1; i <= oState->maxmarks; ++i) {
    oState->markpos[i] = oState->Levels[i].cnt2;
  }

  oState->nodeslo += nodes;
  if (oState->nodeslo < (u32)nodes)
    oState->nodeshi++;

  *pnodes = nodes;

  return retval;
}


/* ************************************************************************* */

#endif /* OGROPT_ALTERNATE_CYCLE == 3 */
