/*
 * For use in distributed.net projects only.
 * Any other distribution or use of this source violates copyright.
 *
 * This file (ogr_g_r.cor) contains the core for OGROPT_ALTERNATE_CYCLE == 0.
 * This is based on GARSP 5.13 "Garry's adaptions of Rado's search principles".
 * There were many modifications ... can anyone tell?
 */
#define __OGR_CORE__ "@(#)$Id: ogr_g_r.cor,v 1.1.2.11.2.1 2001/04/01 19:05:37 andreasb Exp $"

#if (OGROPT_ALTERNATE_CYCLE == 0)

const char* ogr_name()
{
  return "GARSP 5.13 dnet";
}


#define COMP_LEFT_LIST_RIGHT(lev,s)                             \
  {                                                             \
    register int ss = 32 - s;                                   \
    lev->comp[0] = (lev->comp[0] << s) | (lev->comp[1] >> ss);  \
    lev->comp[1] = (lev->comp[1] << s) | (lev->comp[2] >> ss);  \
    lev->comp[2] = (lev->comp[2] << s) | (lev->comp[3] >> ss);  \
    lev->comp[3] = (lev->comp[3] << s) | (lev->comp[4] >> ss);  \
    lev->comp[4] <<= s;                                         \
    lev->list[4] = (lev->list[4] >> s) | (lev->list[3] << ss);  \
    lev->list[3] = (lev->list[3] >> s) | (lev->list[2] << ss);  \
    lev->list[2] = (lev->list[2] >> s) | (lev->list[1] << ss);  \
    lev->list[1] = (lev->list[1] >> s) | (lev->list[0] << ss);  \
    lev->list[0] >>= s;                                         \
  }

#if defined(ASM_ARM) && defined(__GNUC__)
  #define COMP_LEFT_LIST_RIGHT_32(lev) \
  { \
    int a1, a2; \
    \
    asm ("ldr %0,[%2,#44]\n \
          ldr %1,[%2,#48]\n \
          str %0,[%2,#40]\n \
          ldr %0,[%2,#52]\n \
          str %1,[%2,#44]\n \
          ldr %1,[%2,#56]\n \
          str %0,[%2,#48]\n \
          ldr %0,[%2,#12]\n \
          str %1,[%2,#52]\n \
          ldr %1,[%2,#8]\n \
          str %0,[%2,#16]\n \
          ldr %0,[%2,#4]\n \
          str %1,[%2,#12]\n \
          ldr %1,[%2,#0]\n \
          str %0,[%2,#8]\n \
          mov %0,#0\n \
          str %1,[%2,#4]\n \
          str %0,[%2,#56]\n \
          str %0,[%2,#0]" : \
         "=r" (a1), "=r" (a2),\
         "=r" (lev) : "2" (lev)); \
  }
#else
  #define COMP_LEFT_LIST_RIGHT_32(lev)              \
    lev->comp[0] = lev->comp[1];                    \
    lev->comp[1] = lev->comp[2];                    \
    lev->comp[2] = lev->comp[3];                    \
    lev->comp[3] = lev->comp[4];                    \
    lev->comp[4] = 0;                               \
    lev->list[4] = lev->list[3];                    \
    lev->list[3] = lev->list[2];                    \
    lev->list[2] = lev->list[1];                    \
    lev->list[1] = lev->list[0];                    \
    lev->list[0] = 0;
#endif

#if (OGROPT_BITOFLIST_DIRECT_BIT == 0) && (OGROPT_ALTERNATE_CYCLE == 0)
  #define BITOFLIST(x) ogr_bit_of_LIST[x] /* which bit of LIST to update */
  /* ogr_bit_of_LIST[n] = 0x80000000 >> ((n-1) % 32); */
  #define BoL(__n) (0x80000000 >> ((__n - 1) % 32)) //(0x80000000>>((__n - 1)&0x1f))
  static const U ogr_bit_of_LIST[200] = {
        0 , BoL(  1), BoL(  2), BoL(  3), BoL(  4), BoL(  5), BoL(  6), BoL(  7),
  BoL(  8), BoL(  9), BoL( 10), BoL( 11), BoL( 12), BoL( 13), BoL( 14), BoL( 15),
  BoL( 16), BoL( 17), BoL( 18), BoL( 19), BoL( 20), BoL( 21), BoL( 22), BoL( 23),
  BoL( 24), BoL( 25), BoL( 26), BoL( 27), BoL( 28), BoL( 29), BoL( 30), BoL( 31),
  BoL( 32), BoL( 33), BoL( 34), BoL( 35), BoL( 36), BoL( 37), BoL( 38), BoL( 39),
  BoL( 40), BoL( 41), BoL( 42), BoL( 43), BoL( 44), BoL( 45), BoL( 46), BoL( 47),
  BoL( 48), BoL( 49), BoL( 50), BoL( 51), BoL( 52), BoL( 53), BoL( 54), BoL( 55),
  BoL( 56), BoL( 57), BoL( 58), BoL( 59), BoL( 60), BoL( 61), BoL( 62), BoL( 63),
  BoL( 64), BoL( 65), BoL( 66), BoL( 67), BoL( 68), BoL( 69), BoL( 70), BoL( 71),
  BoL( 72), BoL( 73), BoL( 74), BoL( 75), BoL( 76), BoL( 77), BoL( 78), BoL( 79),
  BoL( 80), BoL( 81), BoL( 82), BoL( 83), BoL( 84), BoL( 85), BoL( 86), BoL( 87),
  BoL( 88), BoL( 89), BoL( 90), BoL( 91), BoL( 92), BoL( 93), BoL( 94), BoL( 95),
  BoL( 96), BoL( 97), BoL( 98), BoL( 99), BoL(100), BoL(101), BoL(102), BoL(103),
  BoL(104), BoL(105), BoL(106), BoL(107), BoL(108), BoL(109), BoL(110), BoL(111),
  BoL(112), BoL(113), BoL(114), BoL(115), BoL(116), BoL(117), BoL(118), BoL(119),
  BoL(120), BoL(121), BoL(122), BoL(123), BoL(124), BoL(125), BoL(126), BoL(127),
  BoL(128), BoL(129), BoL(130), BoL(131), BoL(132), BoL(133), BoL(134), BoL(135),
  BoL(136), BoL(137), BoL(138), BoL(139), BoL(140), BoL(141), BoL(142), BoL(143),
  BoL(144), BoL(145), BoL(146), BoL(147), BoL(148), BoL(149), BoL(150), BoL(151),
  BoL(152), BoL(153), BoL(154), BoL(155), BoL(156), BoL(157), BoL(158), BoL(159),
  BoL(160), BoL(161), BoL(162), BoL(163), BoL(164), BoL(165), BoL(166), BoL(167),
  BoL(168), BoL(169), BoL(170), BoL(171), BoL(172), BoL(173), BoL(174), BoL(175),
  BoL(176), BoL(177), BoL(178), BoL(179), BoL(180), BoL(181), BoL(182), BoL(183),
  BoL(184), BoL(185), BoL(186), BoL(187), BoL(188), BoL(189), BoL(190), BoL(191),
  BoL(192), BoL(193), BoL(194), BoL(195), BoL(196), BoL(197), BoL(198), BoL(199)
  #undef BoL
};
#else
  #define BITOFLIST(x) 0x80000000>>((x-1)&0x1f) /*0x80000000 >> ((x-1) % 32)*/
#endif


#if (OGROPT_COPY_LIST_SET_BIT_JUMPS == 1)
#define COPY_LIST_SET_BIT(lev2,lev,bitindex)      \
  {                                               \
    register unsigned int d = bitindex;           \
    lev2->list[0] = lev->list[0];                 \
    lev2->list[1] = lev->list[1];                 \
    lev2->list[2] = lev->list[2];                 \
    lev2->list[3] = lev->list[3];                 \
    lev2->list[4] = lev->list[4];                 \
    if (d <= (32*5))                              \
      lev2->list[(d-1)>>5] |= BITOFLIST( d );     \
  }
#elif (OGROPT_COPY_LIST_SET_BIT_JUMPS == 2)
#define COPY_LIST_SET_BIT(lev2,lev,bitindex)      \
  {                                               \
    register unsigned int d = bitindex;           \
    memcpy( &(lev2->list[0]), &(lev->list[0]), sizeof(lev2->list[0])*5 ); \
    if (d <= (32*5))                              \
      lev2->list[(d-1)>>5] |= BITOFLIST( d );     \
  }
#else
#define COPY_LIST_SET_BIT(lev2,lev,bitindex)      \
  {                                               \
    register unsigned int d = bitindex;           \
    register int bit = BITOFLIST( d );            \
    if (d <= 32) {                                \
       lev2->list[0] = lev->list[0] | bit;        \
       lev2->list[1] = lev->list[1];              \
       lev2->list[2] = lev->list[2];              \
       lev2->list[3] = lev->list[3];              \
       lev2->list[4] = lev->list[4];              \
    } else if (d <= 64) {                         \
       lev2->list[0] = lev->list[0];              \
       lev2->list[1] = lev->list[1] | bit;        \
       lev2->list[2] = lev->list[2];              \
       lev2->list[3] = lev->list[3];              \
       lev2->list[4] = lev->list[4];              \
    } else if (d <= 96) {                         \
       lev2->list[0] = lev->list[0];              \
       lev2->list[1] = lev->list[1];              \
       lev2->list[2] = lev->list[2] | bit;        \
       lev2->list[3] = lev->list[3];              \
       lev2->list[4] = lev->list[4];              \
    } else if (d <= 128) {                        \
       lev2->list[0] = lev->list[0];              \
       lev2->list[1] = lev->list[1];              \
       lev2->list[2] = lev->list[2];              \
       lev2->list[3] = lev->list[3] | bit;        \
       lev2->list[4] = lev->list[4];              \
    } else if (d <= 160) {                        \
       lev2->list[0] = lev->list[0];              \
       lev2->list[1] = lev->list[1];              \
       lev2->list[2] = lev->list[2];              \
       lev2->list[3] = lev->list[3];              \
       lev2->list[4] = lev->list[4] | bit;        \
    } else {                                      \
       lev2->list[0] = lev->list[0];              \
       lev2->list[1] = lev->list[1];              \
       lev2->list[2] = lev->list[2];              \
       lev2->list[3] = lev->list[3];              \
       lev2->list[4] = lev->list[4];              \
    }                                             \
  }
#endif

#define COPY_DIST_COMP(lev2,lev)                  \
  lev2->dist[0] = lev->dist[0] | lev2->list[0];   \
  lev2->dist[1] = lev->dist[1] | lev2->list[1];   \
  lev2->dist[2] = lev->dist[2] | lev2->list[2];   \
  lev2->dist[3] = lev->dist[3] | lev2->list[3];   \
  lev2->dist[4] = lev->dist[4] | lev2->list[4];   \
  lev2->comp[0] = lev->comp[0] | lev2->dist[0];   \
  lev2->comp[1] = lev->comp[1] | lev2->dist[1];   \
  lev2->comp[2] = lev->comp[2] | lev2->dist[2];   \
  lev2->comp[3] = lev->comp[3] | lev2->dist[3];   \
  lev2->comp[4] = lev->comp[4] | lev2->dist[4];

#define COPY_LIST_SET_BIT_COPY_DIST_COMP(lev2,lev,bitindex) \
  {                                   \
    int b, d;                         \
    int a0, a1, a2, a3, a4;           \
                                      \
    b = BITOFLIST(bitindex);          \
    d = bitindex;                     \
    if(d<=32)                         \
    {                                 \
      a0 = lev->list[0] | b;          \
      a1 = lev->list[1];              \
      a2 = lev->list[2];              \
      a3 = lev->list[3];              \
      a4 = lev->list[4];              \
    }                                 \
    else if(d<=64)                    \
    {                                 \
      a0 = lev->list[0];              \
      a1 = lev->list[1] | b;          \
      a2 = lev->list[2];              \
      a3 = lev->list[3];              \
      a4 = lev->list[4];              \
    }                                 \
    else if(d<=96)                    \
    {                                 \
      a0 = lev->list[0];              \
      a1 = lev->list[1];              \
      a2 = lev->list[2] | b;          \
      a3 = lev->list[3];              \
      a4 = lev->list[4];              \
    }                                 \
    else if(d<=128)                   \
    {                                 \
      a0 = lev->list[0];              \
      a1 = lev->list[1];              \
      a2 = lev->list[2];              \
      a3 = lev->list[3] | b;          \
      a4 = lev->list[4];              \
    }                                 \
    else if(d<=160)                   \
    {                                 \
      a0 = lev->list[0];              \
      a1 = lev->list[1];              \
      a2 = lev->list[2];              \
      a3 = lev->list[3];              \
      a4 = lev->list[4] | b;          \
    }                                 \
    else                              \
    {                                 \
      a0 = lev->list[0];              \
      a1 = lev->list[1];              \
      a2 = lev->list[2];              \
      a3 = lev->list[3];              \
      a4 = lev->list[4];              \
    }                                 \
    lev2->list[0] = a0;               \
    lev2->list[1] = a1;               \
    lev2->list[2] = a2;               \
    lev2->list[3] = a3;               \
    b = lev->dist[0];                 \
    lev2->list[4] = a4;               \
    a0 = b | a0;                      \
    b = lev->dist[1];                 \
    lev2->dist[0] = a0;               \
    a1 = b | a1;                      \
    b = lev->dist[2];                 \
    lev2->dist[1] = a1;               \
    a2 = b | a2;                      \
    b = lev->dist[3];                 \
    lev2->dist[2] = a2;               \
    a3 = b | a3;                      \
    b = lev->dist[4];                 \
    lev2->dist[3] = a3;               \
    a4 = b | a4;                      \
    b = lev->comp[0];                 \
    lev2->dist[4] = a4;               \
    a0 = b | a0;                      \
    b = lev->comp[1];                 \
    lev2->comp[0] = a0;               \
    a1 = b | a1;                      \
    b = lev->comp[2];                 \
    lev2->comp[1] = a1;               \
    a2 = b | a2;                      \
    b = lev->comp[3];                 \
    lev2->comp[2] = a2;               \
    a3 = b | a3;                      \
    b = lev->comp[4];                 \
    lev2->comp[3] = a3;               \
    a4 = b | a4;                      \
    lev2->comp[4] = a4;               \
  }


/* ************************************************************************* */


static int found_one(const struct State *oState)
{
  /* confirm ruler is golomb */
  {
    register int i, j;
    #if (OGROPT_FOUND_ONE_FOR_SMALL_DATA_CACHE == 2)
    char diffs[((1024-64)+7)/8];
    #elif (OGROPT_FOUND_ONE_FOR_SMALL_DATA_CACHE == 1)
    char diffs[((1024)+7)/8];
    #else
    char diffs[1024];
    #endif
    register int max = oState->max;
    register int maxmarks = oState->maxmarks;
    #if 1 /* (OGROPT_FOUND_ONE_FOR_SMALL_DATA_CACHE == 1) || \
             (OGROPT_FOUND_ONE_FOR_SMALL_DATA_CACHE == 2) */
    memset( diffs, 0, sizeof(diffs) );
    #else
    for (i = max>>1; i>=1; i--) diffs[i] = 0;
    #endif
    for (i = 1; i < maxmarks; i++) {
      register int marks_i = oState->Levels[i].cnt2;
      for (j = 0; j < i; j++) {
        register int diff = marks_i - oState->Levels[j].cnt2;
        if (diff+diff <= max) {        /* Principle 1 */
          if (diff <= 64) break;      /* 2 bitmaps always tracked */
          #if (OGROPT_FOUND_ONE_FOR_SMALL_DATA_CACHE == 2) || \
              (OGROPT_FOUND_ONE_FOR_SMALL_DATA_CACHE == 1)
          {
            register int mask;
            #if (OGROPT_FOUND_ONE_FOR_SMALL_DATA_CACHE == 2)
            diff -= 64;
            #endif
            mask = 1<<(diff&7);
            diff >>= 3;
            if ((diffs[diff] & mask)!=0) return 0;
            diffs[diff] |= (char)mask;
          }
          #else
          if (diffs[diff]) return 0;
          diffs[diff] = 1;
          #endif
        }
      }
    }
  }
  return 1;
}


/* ************************************************************************* */


static int ogr_create(void *input, int inputlen, void *state, int statelen)
{
  struct State *oState;
  struct WorkStub *workstub = (struct WorkStub *)input;
  int retval = CORE_S_OK;
  /* save STUB_E_ error codes into oState->stub_error and finish ogr_create() 
     to allow a graceful discard in case of a STUB_E_ */

  if (!input || inputlen != sizeof(struct WorkStub)) {
    return CORE_E_FORMAT;
  }

  if (((unsigned int)statelen) < sizeof(struct State)) {
    return CORE_E_FORMAT;
  }
  oState = (struct State *)state;
  if (!oState) {
    return CORE_E_MEMORY;
  }

  memset(oState, 0, sizeof(struct State));
  /* initialize lock here if we had one */

  oState->stub_error = STUB_OK; 
  /* stub_error stores the STUB_E_ error codes. An oState with a non zero 
     stub_error will be rejected by ogr_cycle(), but returned to network */
    
  oState->maxmarks = workstub->stub.marks;
  oState->maxdepth = oState->maxmarks-1;

  if (((unsigned int)oState->maxmarks) > (sizeof(OGR_length)/sizeof(OGR_length[0]))) {
    return CORE_E_FORMAT;
  }

  oState->max = OGR_length[oState->maxdepth];

  /* Note, marks are labled 0, 1...  so mark @ depth=1 is 2nd mark */
  oState->half_depth2 = oState->half_depth = ((oState->maxmarks+1) >> 1) - 1;
  if (!(oState->maxmarks % 2)) oState->half_depth2++;  /* if even, use 2 marks */

  /* Simulate GVANT's "KTEST=1" */
  oState->half_depth--;
  oState->half_depth2++;
  /*------------------
  Since:  half_depth2 = half_depth+2 (or 3 if maxmarks even) ...
  We get: half_length2 >= half_length + 3 (or 6 if maxmarks even)
  But:    half_length2 + half_length <= max-1    (our midpoint reduction)
  So:     half_length + 3 (6 if maxmarks even) + half_length <= max-1
  ------------------*/
                               oState->half_length = (oState->max-4) >> 1;
  if ( !(oState->maxmarks%2) ) oState->half_length = (oState->max-7) >> 1;

  oState->depth = 1;
  
#ifdef OGROPT_NEW_CHOOSEDAT
  /* would we choose values somewhere behind the precalculated values from 
     ogr_choose_dat2 ? 
     choose(x,y) will be called from middle and right segment for the 
     remaining ruler, not including the current mark, so we can subtract 1 */
  if (oState->maxdepth - oState->half_depth - 1 > CHOOSE_MAX_DEPTH)
    oState->stub_error |= STUB_E_MARKS;  
#endif

#if (OGROPT_ALTERNATE_CYCLE == 0)

  {
    int i, n;
    struct Level *lev, *lev2;

    n = workstub->worklength;
    if (n < workstub->stub.length) {
      n = workstub->stub.length;
    }
    if (n > STUB_MAX) {
      return CORE_E_FORMAT;
    }

    /* // level 0 - already done by memset
    lev = &oState->Levels[0];
    lev->cnt1 = lev->cnt2 = oState->markpos[0] = 0;
    lev->limit = lev->maxlimit = 0;
    */
    
    lev = &oState->Levels[1];
    for (i = 0; i < n; i++) {
      int limit;
      if (oState->depth <= oState->half_depth2) {
        if (oState->depth <= oState->half_depth) {
          limit = oState->max - OGR_length[oState->maxdepth - oState->depth];
          limit = limit < oState->half_length ? limit : oState->half_length;
        } else {
          limit = oState->max - choose(lev->dist[0] >> ttmDISTBITS, oState->maxdepth - oState->depth);
          limit = limit < oState->max - oState->markpos[oState->half_depth]-1 ? limit : oState->max - oState->markpos[oState->half_depth]-1;
        }
      } else {
        limit = oState->max - choose(lev->dist[0] >> ttmDISTBITS, oState->maxdepth - oState->depth);
      }
      lev->limit = limit;
      register int s = workstub->stub.diffs[i];
      
      if (s <= (32*5))
        if (lev->comp[(s-1)>>5] & BITOFLIST(s))
          oState->stub_error |= STUB_E_GOLOMB;

      //dump(oState->depth, lev, 0);
      oState->markpos[i+1] = oState->markpos[i] + s;
      if ((lev->cnt2 += s) > limit)
        oState->stub_error |= STUB_E_LIMIT;

      register int t = s;
      while (t >= 32) {
        COMP_LEFT_LIST_RIGHT_32(lev);
        t -= 32;
      }
      if (t > 0) {
        COMP_LEFT_LIST_RIGHT(lev, t);
      }
      lev2 = lev + 1;
      COPY_LIST_SET_BIT(lev2, lev, s);
      COPY_DIST_COMP(lev2, lev);
      lev2->cnt1 = lev->cnt2;
      lev2->cnt2 = lev->cnt2;
      lev++;
      oState->depth++;
    }
    oState->depth--; // externally visible depth is one less than internal
  }

#else 
  #error no core specific ogr_create() code
#endif

  oState->startdepth = workstub->stub.length;
  oState->stopdepth = workstub->stub.length; // FIXME for NewStub

#ifdef OGR_WINDOW
   oState->wind = oState->depth;
   oState->turn = 0;
#endif
#ifdef OGR_PROFILE
   oState->prof.hd = 0;
   oState->prof.hd2 = 0;
   oState->prof.ghd = 0;
   oState->prof.lt16 = 0;
   oState->prof.lt32 = 0;
   oState->prof.ge32 = 0;
   oState->prof.fo = 0;
   oState->prof.push = 0;
#endif
#ifdef OGR_DEBUG
  printf("sizeof      = %d\n", sizeof(struct State));
  printf("max         = %d\n", oState->max);
  printf("maxmarks    = %d\n", oState->maxmarks);
  printf("maxdepth    = %d\n", oState->maxdepth);
  printf("half_length = %d\n", oState->half_length);
  printf("half_depth  = %d\n", oState->half_depth);
  printf("half_depth2 = %d\n", oState->half_depth2);
  {
    int i;
    printf("marks       = ");
     for (i = 1; i <= oState->depth; i++) {
      printf("%d ", oState->markpos[i]-oState->markpos[i-1]);
    }
    printf("\n");
  }
#endif

  return retval;
}


/* ************************************************************************* */


static int ogr_cycle(void *state, int *pnodes, int with_time_constraints)
{
  struct State *oState = (struct State *)state;
  /* oState->depth is the level of the last placed mark */
  int depth = oState->depth+1;      /* the depth of recursion */
  /* our depth is the level where the next mark will be placed */
  struct Level *lev = &oState->Levels[depth];
  struct Level *lev2;
  int nodes = 0;
  int nodeslimit = *pnodes;
  int retval = CORE_S_CONTINUE;
  int limit;
  U comp0;
  
  /* ogr_cycle() must be thread safe. Only modification of part 3 of oState is
   * allowed. Part 2 will be updated before leaving ogr_cycle after locking a
   * mutex.
   */

  if (oState->stub_error != STUB_OK) {
    *pnodes = 0;
    return CORE_S_OK; /* stub is "finished" */
  }
  
  OGR_DEBUG_CYCLE( oState->LOGGING = 1; )
  
  for (;;) {

    if (with_time_constraints) { /* if (...) is optimized away if unused */
       #if !defined(OGROPT_IGNORE_TIME_CONSTRAINT_ARG)
       if (nodes >= nodeslimit) {
         break;
       }  
       #endif  
    }

    OGR_DEBUG_CYCLE( if (oState->LOGGING) dump_ruler(oState, depth); )

    if (depth <= oState->half_depth2) {
      if (depth <= oState->half_depth) {

        //dump_ruler(oState, depth);
        if (nodes >= nodeslimit) {
          break;
        }

        limit = oState->max - OGR_length[oState->maxdepth - depth];
        limit = limit < oState->half_length ? limit : oState->half_length;
      } else {
        limit = oState->max - choose(lev->dist[0] >> ttmDISTBITS, oState->maxdepth - depth);
        //limit = limit < oState->max - oState->markpos[oState->half_depth]-1  
        //        ? limit : oState->max - oState->markpos[oState->half_depth]-1;
        limit = limit < oState->max - oState->Levels[oState->half_depth].cnt2-1  
                ? limit : oState->max - oState->Levels[oState->half_depth].cnt2-1;
      }
    } else {
      limit = oState->max - choose(lev->dist[0] >> ttmDISTBITS, oState->maxdepth - depth);
    }

    OGR_DEBUG_CYCLE( if (oState->LOGGING) dump(depth, lev, limit); )

    nodes++;

    /* Find the next available mark location for this level */
stay:
    comp0 = lev->comp[0];
    OGR_DEBUG_CYCLE( if (oState->LOGGING) printf("comp0=%08x\n", comp0); )
    if (comp0 < 0xfffffffe) {
      int s = LOOKUP_FIRSTBLANK( comp0 );
      OGR_DEBUG_CYCLE( if (oState->LOGGING) printf("depth=%d s=%d len=%d limit=%d\n", depth, s+(lev->cnt2-lev->cnt1), lev->cnt2+s, limit); )
      if ((lev->cnt2 += s) > limit) goto up; /* no spaces left */
      COMP_LEFT_LIST_RIGHT(lev, s);
    } else {
      /* s>32 */
      if ((lev->cnt2 += 32) > limit) goto up; /* no spaces left */
      COMP_LEFT_LIST_RIGHT_32(lev);
      if (comp0 == 0xffffffff) goto stay;
    }

/* ogr_cycle is being used for stubmap generation ... */
#ifdef OGR_CALLBACK
    if (depth == ogr_callback_depth) {
      // update part 2 of oState
      /* ogr_getresult() and ogr_cycle() must interact thread safe */  
      /* lock state lock here if we had one */

      oState->depth = depth;

      for (int i = oState->startdepth+1; i <= oState->maxmarks; ++i) {
        oState->markpos[i] = oState->Levels[i].cnt2;
      }
      
      // don't update oState->nodes[hi|lo] !

      /* unlock state lock here if we had one */
      
      if (ogr_callback(oState) != 0)
        break;

      goto stay; /* don't go deeper, but repeat this level till done */
    }
#endif

    /* New ruler? */
    if (depth == oState->maxdepth) {
      //oState->markpos[oState->maxdepth] = lev->cnt2;       /* not placed yet into list arrays! */
      /* found_one() doesn't use part 2 of State */
      if (found_one(oState)) {
        retval = CORE_S_SUCCESS;
        break;
      }
      goto stay;
    }

    /* Go Deeper */
    lev2 = lev + 1;
#if (OGROPT_COMBINE_COPY_LIST_SET_BIT_COPY_DIST_COMP == 1)
    COPY_LIST_SET_BIT_COPY_DIST_COMP(lev2, lev, lev->cnt2-lev->cnt1);
#else
    COPY_LIST_SET_BIT(lev2, lev, lev->cnt2-lev->cnt1);
    COPY_DIST_COMP(lev2, lev);
#endif
    //oState->markpos[depth] = lev->cnt2;
    lev2->cnt1 = lev->cnt2;
    lev2->cnt2 = lev->cnt2;
    lev->limit = limit;
    //oState->depth = depth;
    lev++;
    depth++;

    continue;

up:
    lev--;
    depth--;
    //oState->depth = depth-1;
    if (depth <= oState->stopdepth) {
      retval = CORE_S_OK;
      break;
    }
    limit = lev->limit;

    goto stay; /* repeat this level till done */
  }

  /* ogr_getresult() and ogr_cycle() must interact thread safe */

  /* lock the changing part of public data (part 2) for updating here */

  oState->depth = depth-1;

  for (int i = oState->startdepth+1; i <= oState->maxmarks; ++i) {
    oState->markpos[i] = oState->Levels[i].cnt2;
  }

  oState->nodeslo += nodes;
  if (oState->nodeslo < (u32)nodes)
    oState->nodeshi++;

  /* release lock here */

  *pnodes = nodes;

  return retval;
}


/* ************************************************************************* */

#endif /* OGROPT_ALTERNATE_CYCLE == 0 */
